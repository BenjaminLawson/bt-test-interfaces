// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

option java_outer_classname = "HostProto";

package pandora;

import "google/protobuf/empty.proto";

// Service to trigger Bluetooth Host procedures
//
// At startup, the Host must be in BR/EDR connectable mode
// (see GAP connectability modes)
service Host {
  // Hard reset the host.
  // **After** responding to this command, the gRPC server should loose
  // all its state.
  // This is comparable to a process restart or an hardware reset.
  // The gRPC server might take some time to be available after
  // this command.
  rpc HardReset(google.protobuf.Empty) returns (google.protobuf.Empty);
  // Soft reset the host by performing an HCI reset. Previous bonds must
  // not be removed and the gRPC server must not be restarted.
  rpc SoftReset(google.protobuf.Empty) returns (google.protobuf.Empty);
  // Read the local Bluetooth device address.
  // This should return the same value as a Read BD_ADDR HCI command.
  rpc ReadLocalAddress(google.protobuf.Empty) returns (ReadLocalAddressResponse);
  // Create an ACL BR/EDR connection to a peer.
  // If the two devices have not established a previous bond,
  // the peer must be discoverable.
  // By default, this triggers pairing and accept it if necessary.
  // This behavior can be changed by specifying flags in the request.
  rpc Connect(ConnectRequest) returns (ConnectResponse);
  // Get an active ACL BR/EDR connection to a peer.
  rpc GetConnection(GetConnectionRequest) returns (GetConnectionResponse);
  // Wait for an ACL BR/EDR connection from a peer.
  // By default, this accepts pairing if necessary.
  // This behavior can be changed by specifying flags in the request.
  rpc WaitConnection(WaitConnectionRequest) returns (WaitConnectionResponse);
  // Create an ACL LE connection.
  // This does not trigger pairing/encryption.
  rpc ConnectLE(ConnectLERequest) returns (ConnectLEResponse);
  // Get an active ACL LE connection to a peer.
  rpc GetLEConnection(GetLEConnectionRequest) returns (GetLEConnectionResponse);
  // Disconnect an ACL connection.
  // The related Connection must not be reused afterwards.
  rpc Disconnect(DisconnectRequest) returns (google.protobuf.Empty);
  // Create and enable an advertising set using legacy or extended advertising,
  // except periodic advertising.
  rpc StartAdvertising(StartAdvertisingRequest) returns (StartAdvertisingResponse);
  // Remove an advertising set.
  rpc StopAdvertising(StopAdvertisingRequest) returns (google.protobuf.Empty);
  // Run LE scanning and return each device found.
  rpc StartScanning(StartScanningRequest) returns (stream StartScanningResponse);
  // Stop LE scanning.
  rpc StopScanning(google.protobuf.Empty) returns (google.protobuf.Empty);
  // Start BR/EDR inquiry and returns each device found.
  rpc StartInquiry(google.protobuf.Empty) returns (stream StartInquiryResponse);
  // Stop BR/EDR inquiry.
  rpc StopInquiry(google.protobuf.Empty) returns (google.protobuf.Empty);
  // Set BR/EDR discoverability mode.
  rpc SetDiscoverabilityMode(SetDiscoverabilityModeRequest) returns (google.protobuf.Empty);
  // Set BR/EDR connectability mode.
  rpc SetConnectabilityMode(SetConnectabilityModeRequest) returns (google.protobuf.Empty);
  // Get remote device name from connection.
  rpc GetRemoteName(GetRemoteNameRequest) returns (GetRemoteNameResponse);
}

// Bluetooth Device address type.
enum AddressType {
  PUBLIC = 0x00;
  RANDOM = 0x01;
  PUBLIC_IDENTITY = 0x02;
  RANDOM_IDENTITY = 0x03;
}

// Bluetooth transport type.
enum Transport {
  TRANSPORT_BREDR = 0;
  TRANSPORT_LE = 1;
}

// Advertisement primary PHY types.
enum PrimaryPhy {
  PRIMARY_1M = 0;
  PRIMARY_CODED = 2;
}

// Advertisement secondary PHY types.
enum SecondaryPhy {
  SECONDARY_1M = 0;
  SECONDARY_2M = 1;
  SECONDARY_CODED = 2;
}

// Discoverability modes (BR/EDR only).
enum DiscoverabilityMode {
  NOT_DISCOVERABLE = 0;
  DISCOVERABLE_LIMITED = 1;
  DISCOVERABLE_GENERAL = 2;
}

// Connectability modes (BR/EDR only).
enum ConnectabilityMode {
  NOT_CONNECTABLE = 0;
  CONNECTABLE = 1;
}

// A Token representing an ACL connection.
// It's acquired via a `Connect` or `ConnectLE`.
message Connection {
  // Opaque value filled by the gRPC server, must not be modified nor crafted.
  bytes cookie = 1;
  // Connection transport.
  Transport transport = 2;
}

// A Token representing an Advertising set.
// It's acquired via a StartAdvertising on the Host service.
message AdvertisingSet {
  // Opaque value filled by the gRPC server, must not be modified nor crafted.
  bytes cookie = 1;
}

// Data types notably used for Extended Inquiry Response and Advertising Data.
// The Flags data type is mandatory must be automatically set by the IUT and is
// not exposed here.
// include_<data type> are used in advertising requests for data types
// which may not be exposed to the user and that must be set by the IUT
// when specified.
// See Core Supplement, Part A, Data Types for details.
message DataTypes {
  repeated string incomplete_service_class_uuids16 = 1; // Incomplete List of 16bit Service Class UUIDs
  repeated string complete_service_class_uuids16 = 2; // Complete List of 16bit Service Class UUIDs
  repeated string incomplete_service_class_uuids32 = 3; // Incomplete List of 32bit Service Class UUIDs
  repeated string complete_service_class_uuids32 = 4; // Complete List of 32bit Service Class UUIDs
  repeated string incomplete_service_class_uuids128 = 5; // Incomplete List of 128bit Service Class UUIDs
  repeated string complete_service_class_uuids128 = 6; // Complete List of 128bit Service Class UUIDs
  // Shortened Local Name
  oneof shortened_local_name_oneof {
    string shortened_local_name = 7;
    bool include_shortened_local_name = 8;
  }
  // Complete Local Name
  oneof complete_local_name_oneof {
    string complete_local_name = 9;
    bool include_complete_local_name = 10;
  }
  // Tx Power Level
  oneof tx_power_level_oneof {
    uint32 tx_power_level = 11;
    bool include_tx_power_level = 12;
  }
  //  Class of Device
  oneof class_of_device_oneof {
    uint32 class_of_device = 13;
    bool include_class_of_device = 14;
  }
  uint32 peripheral_connection_interval_min = 15; // Peripheral Connection Interval Range minimum value, 16 bits
  uint32 peripheral_connection_interval_max = 16; // Peripheral Connection Interval Range maximum value, 16 bits
  repeated string service_solicitation_uuids16 = 17; // List of 16bit Service Solicitation UUIDs
  repeated string service_solicitation_uuids128 = 18; // List of 128bit Service Solicitation UUIDs
  map<string, bytes> service_data_uuid16 = 19; // Service Data 16bit UUID
  repeated bytes public_target_addresses = 20; // Public Target Addresses
  repeated bytes random_target_addresses = 21; // Random Target Addresses
  uint32 appearance = 22; // Appearance (16bits)
  // Advertising Interval
  oneof advertising_interval_oneof {
    uint32 advertising_interval = 23; // 16 bits
    bool include_advertising_interval = 24;
  }
  repeated string service_solicitation_uuids32 = 25; // List of 32bit Service Solicitation UUIDs
  map<string, bytes> service_data_uuid32 = 26; // Service Data 32bit UUID
  map<string, bytes> service_data_uuid128 = 27; // Service Data 128bit UUID
  string uri = 28; // URI
  bytes le_supported_features = 29; // LE Supported Features
  bytes manufacturer_specific_data = 30; // Manufacturer Specific Data
}

// Response of the `ReadLocalAddress` method.
message ReadLocalAddressResponse {
  // Local Bluetooth Device address as array of 6 bytes.
  bytes address = 1;
}

// Request of the `Connect` method.
message ConnectRequest {
  // Peer Bluetooth Device address as array of 6 bytes.
  bytes address = 1;
  // Whether we want to initiate pairing as part of the connection.
  bool skip_pairing = 2;
  // Whether confirmation prompts should be auto-accepted or handled manually.
  bool manually_confirm = 3;
}

// Response of the `Connect` method.
message ConnectResponse {
  // Connection on `Connect` success
  Connection connection = 1;
}

// Request of the `GetConnection` method.
message GetConnectionRequest {
  // Peer Bluetooth Device address as array of 6 bytes.
  bytes address = 1;
}

// Response of the `GetConnection` method.
message GetConnectionResponse {
  // Connection on `GetConnection` success
  Connection connection = 1;
}

// Request of the `WaitConnection` method.
message WaitConnectionRequest {
  // Peer Bluetooth Device address as array of 6 bytes.
  bytes address = 1;
  // Whether confirmation prompts should be auto-accepted or handled manually.
  bool manually_confirm = 2;
}

// Response of the `WaitConnection` method.
message WaitConnectionResponse {
  // Connection on `WaitConnection` success
  Connection connection = 1;
}

// Request of the `ConnectLE` method
message ConnectLERequest {
  // Peer Bluetooth Device address as array of 6 bytes.
  bytes address = 1;
  // Peer Bluetooth Device address type.
  AddressType address_type = 2;
}

// Response of the `ConnectLE` method
message ConnectLEResponse {
  // Connection on `ConnectLE` success
  Connection connection = 1;
}

// Request of the `GetLEConnection` method
message GetLEConnectionRequest {
  // Peer Bluetooth Device address as array of 6 bytes.
  bytes address = 1;
}

// Response of the `GetLEConnection` method
message GetLEConnectionResponse {
  // Connection on `GetLEConnection` success
  Connection connection = 1;
}

// Request of the `Disconnect` method.
message DisconnectRequest {
  // Connection that should be disconnected.
  Connection connection = 1;
}

// Request of the `StartAdvertising` method
message StartAdvertisingRequest {
  // Advertisement data.
  DataTypes data = 1;
  // If none, the device is not scannable.
  DataTypes scan_response_data = 2;
  // Target Bluetooth Device address as array of 6 bytes.
  // If none, advertisement is undirected.
  bytes target = 3;
  // Target Bluetooth Device address type.
  // Only used when `target` is set.
  AddressType target_address_type = 4;
  // Own address type to advertise.
  AddressType own_address_type = 5;
  // `true` if the device is connectable.
  bool is_connectable = 6;
  // Interval & range of the advertisement.
  float interval = 7;
  // If not specified, the IUT is free to select any interval min and max
  // which comprises the specified interval.
  float interval_range = 8;

  // `true` if the advertisement is extended.
  // The fields bellow are only used in case of extended advertisement.
  bool extended = 9;
  // Extended only: primary PHYs.
  PrimaryPhy primary_phy = 10;
  // Extended only: secondary PHYs.
  SecondaryPhy secondary_phy = 11;
}

// Response of the `StartAdvertising` method
message StartAdvertisingResponse {
  AdvertisingSet set = 1;
}

// Request of the `StopAdvertising` method
message StopAdvertisingRequest {
  // AdvertisingSet that should be stopped.
  AdvertisingSet set = 1;
}

// Request of the `StartScanning` method
message StartScanningRequest {
  // Interval & window of the scan.
  float interval = 1;
  float window = 2;

  // `true` if the scanning is extended.
  // The fields bellow are only used in case of extended scanning.
  bool extended = 3;
  // Scanning PHYs.
  repeated PrimaryPhy phys = 4;
}

// Response of the `StartScanning` method
message StartScanningResponse {
  // `true` if the response is extended.
  bool extended = 1;
  // Peer Bluetooth Device address as array of 6 bytes.
  bytes address = 2;
  // Peer Bluetooth Device address type.
  AddressType address_type = 3;
  // `true` if the peer is connectable.
  bool is_connectable = 4;
  // `true` if the peer is scannable.
  bool is_scannable = 5;
  // `true` if the `undirected.data` is truncated.
  // This indicates that the advertisement data are truncated.
  bool is_truncated = 6;
  // Advertising SID from 0x00 to 0x0F.
  uint32 sid = 7;
  // On extended only: primary PHYs.
  PrimaryPhy primary_phy = 8;
  // On extended only: secondary PHYs.
  SecondaryPhy secondary_phy = 9;
  // TX power in dBm, range: -127 to +20.
  int32 tx_power = 10;
  // Received Signal Strenght Indication in dBm, range: -127 to +20.
  int32 rssi = 11;
  // Interval of the periodic advertising, 0 if not periodic
  // or within 7.5 ms to 81,918.75 ms range.
  float periodic_advertising_interval = 12;
  // Scan response data.
  DataTypes data = 13;
}

// Response of the `StartInquiry` method
message StartInquiryResponse {
  bytes address = 1;
  uint32 page_scan_rep_mode = 2;
  uint32 class_of_device = 3;
  uint32 clock_offset = 4;
  int32 rssi = 5;
  DataTypes data = 6;
}

// Request of the `SetDiscoverabilityMode` method
message SetDiscoverabilityModeRequest {
  DiscoverabilityMode mode = 1;
}

// Request of the `SetConnectabilityMode` method
message SetConnectabilityModeRequest {
  ConnectabilityMode mode = 1;
}

// Request of the `GetRemoteName` method
message GetRemoteNameRequest {
  oneof remote {
    // ACL connection with remote device.
    Connection connection = 1;
    // Remote Bluetooth Device address as array of 6 bytes.
    bytes address = 2;
  }
}

// Response of the `GetRemoteName` method
message GetRemoteNameResponse {
  // Remote name.
  string name = 1;
}
